---
Title: Philosophy and programming
---
This is notes for something I threatened to do on Twitter a couple of years ago. It might turn into a standalone essay, or it could end up as part of the language/functional paradigm series of blog posts that I've started.

This isn't just about the terms that programming and maths have stolen from philosophy, like "ontology" and "functor": programming paradigms and languages embody relationships between being and becoming, subject and object, world and time, in ways which make them in some sense a metaphysics. The idea is to line up languages from the history of CS with philosophical positions in a way which is mostly just witty but also in some sense true. There's no point to the jokes unless they reflect something real.

Part of the joke is also computing as a recapitulation of the history of philosophy, so old languages map to old philosophies.

## Foundational concepts

Some philosophical axes on which languages can be situated:

### materialist - idealist

Materialist languages are close to the metal - assembler, C, C++, Rust, Go.  Idealist languages have variables which are abstracted away from the machine - Lisp, Perl, Java, Python

### subjective - objective

One way: introspection (in the language sense) maps onto subjectivity, so languages like Lisp, Haskell and Python have "subjectivity" in a way which other languages don't. On the other hand, "code is data" languages actually blend subjectivity and objectivity.

This kind of runs parallel to materialist/idealist: subjective languages are also idealist and objective languages are materialist.

### positivist - constructivist

## Quick List

FORTRAN      - Aristotle
Lisp         - Plato
BASIC        -
Pascal       - Hellenistic Neoplatonism
assembler    - pre-socratics
Forth        - logical positivism
C            - naturalist empiricism
Visual Basic - 
C++          -  
Ada
Scheme         - Kant
shell scripts  - vulgar Marxism
Perl           - Jamesian pragmatism
Python
Ruby      
PHP         - Feyerabend
Java         
Javascript
ML
Haskell     - Prigogine
Lua
Smalltalk   
Logo        - 

# Elaboration

LISP, an ancient language, beloved by generations of programmers for
its elegant lack of syntax and powers of introspection far in advance
of any other high-level language.  LISP is a language in which there
is no essential difference between code and data: this property,
homoiconicity, may be compared to the philosophical principle of
monism, the idea that the Universe is composed of only one essential
substance. Were it not for this, the analogy that leaps to mind for
LISP is Platonism, for LISP is something of a programmer's programming
language, and shares with musicians' musicians a certain solipsistic
elitism.  The smugness of "LISP weenies" is notorious and compares
with the implicit self-congratulation of Plato's philosopher-king.

LISP, like Platonism, is at home in the academy: of its many
descendants, the most influential is possibly Scheme, which served as
the language of the first-year programming course for many years. And,
like Platonism, LISP is a high-minded attempt to model thought
itself, one which sought high office in its early years but was
eventually reduced to a form of mysticism and pedagogy.

LISP is a high-level language: the variables which it deals with are
abstracted up from the actual mechanism of their storage, a concept
which corresponds with the Platonic theory of the Form, which is
strictly independent of and superior to whatever substance it is
embodied in.

###

It is a truism that Western philosophy is a dialogue between Plato and
Aristotle: LISP's only rival for age among languages still in use is
FORTRAN. FORTRAN, as its capitalised name implies, is even older than
LISP, but where the latter emphasises purity and elegance over
pragmatism, and threatens to float off into an empyrean of pure
ideation, the former is strictly about getting things done.  Fortran's
name is an abbreviation for FORMULA TRANSLATION and its only purpose
is scientific and mathematical programming.

Fortran is impure, down and dirty imperative programming at its least
elegant: whereas LISP, like Socrates, poses intriguing and stylish abstract
questions to well-heeled students, Fortran, like Aristotle, can be
frustratingly clumsy to read and understand, but is much more engaged
with solving problems.  Aristotle's teleological thought finds its
match in Fortran's practicality: unlike Lisp's advanced
metaprogramming culture, which has a "look I can put my own fist in my
mouth" attitude (OK, you can do that, the onlooker wonders, but is
there any reason why you should?), no-one in the history of coding
ever wrote a Fortram program unless they were trying to solve a
problem.

Aristotle is a philospher to whom posterity has not been particularly
kind: what was left of his reputation after Reformation's opinion of
Scholasticism was pretty much hammered by the biologists, who are
still prone to take spiteful stabs at him.  But, as Armand Marie Leroi
points out, he pretty much invented empirical, systematic science,
and, telos aside, your average modern person's view of how the world
works is more Aristotelian than Platonist.  And every research
computing cluster in the world is guaranteed to have some Fortran
running on it, still out there, crunching the numbers.

